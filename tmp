subroutine calcCoupling2_0(NumStates,HalfBandWidth,MatrixDim,RDerivDelt,lPsi,mPsi,rPsi,S,P,Q,dP)
  implicit none
  integer NumStates,HalfBandWidth,MatrixDim
  double precision RDerivDelt
  double precision lPsi(MatrixDim,NumStates),mPsi(MatrixDim,NumStates),rPsi(MatrixDim,NumStates)
  double precision S(HalfBandWidth+1,MatrixDim),testorth
  double precision P(NumStates,NumStates),Q(NumStates,NumStates),dP(NumStates,NumStates)

  integer i,j,k,m,n
  double precision aP,aQ,ddot
  double precision, allocatable :: lDiffPsi(:),rDiffPsi(:),TempPsi(:),TempPsiB(:),rSumPsi(:)
  double precision, allocatable :: TempmPsi(:)

  allocate(lDiffPsi(MatrixDim),rDiffPsi(MatrixDim),TempPsi(MatrixDim),&
       TempPsiB(MatrixDim),rSumPsi(MatrixDim))
  allocate(TempmPsi(MatrixDim))

  aP = 0.5d0/RDerivDelt !RDerivDelt
  aQ = aP*aP

  do j = 1,NumStates
     do k = 1,MatrixDim
        rDiffPsi(k) = rPsi(k,j)-lPsi(k,j)
        rSumPsi(k)  = lPsi(k,j)+mPsi(k,j)+rPsi(k,j)  ! Double check this is needed for <Phi'(R)|Phi'(R)>
        !            rSumPsi(k)  = lPsi(k,j)-2.0d0*mPsi(k,j)+rPsi(k,j)
        !            rSumPsi(k)  = lPsi(k,j)+rPsi(k,j)
     enddo
     call dsbmv('U',MatrixDim,HalfBandWidth,1.0d0,S,HalfBandWidth+1,rDiffPsi,1,0.0d0,TempPsi,1)   ! Calculate the vector S*rDiffPsi
     call dsbmv('U',MatrixDim,HalfBandWidth,1.0d0,S,HalfBandWidth+1,rSumPsi,1,0.0d0,TempPsiB,1)   ! Calculate the vector S*rSumPsi
     call dsbmv('U',MatrixDim,HalfBandWidth,1.0d0,S,HalfBandWidth+1,mPsi(1,j),1,0.0d0,TempmPsi,1) ! Calculate the vector S*mPsi(1,j)

     do i = 1,NumStates

        !            testorth=ddot(MatrixDim,mPsi(1,i),1,TempmPsi,1)
        !            write(309,*) i,j, '   testorth=',testorth

        P(i,j) = aP*ddot(MatrixDim,mPsi(1,i),1,TempPsi,1) + kronecker_delta/RDerivDelt
        dP(i,j)= ddot(MatrixDim,mPsi(1,i),1,TempPsiB,1)

        do k = 1,MatrixDim
           lDiffPsi(k) = rPsi(k,i)-lPsi(k,i)
        enddo
        Q(i,j) = -aQ*ddot(MatrixDim,lDiffPsi,1,TempPsi,1) !symmetric Q = -P^2
     enddo
  enddo

  do j=1,NumStates
     do i=j,NumStates
        dP(i,j)=2.d0*aQ*(dP(i,j)-dP(j,i))
        dP(j,i)=-dP(i,j)
     enddo
  enddo

  deallocate(lDiffPsi,rDiffPsi,TempPsi,rSumPsi,TempPsiB,TempmPsi)

  return

  contains

  double precision function kronecker_delta(m,n)
      integer m,n
      if (m .eq. n) then
         kronecker_delta = 1
      else
         kronecker_delta = 0
      endif
   end function kronecker_delta

end subroutine calcCoupling2_0
